#　10.5  让各个目录下的代码在统一的命名空间下导入
# 10.5.1 问题

# 我们有一个庞大的代码库，其中有很多部分可能是由不同的人来维护和发布的。每个部分都组织成一个目录，就像包一样。但是，与其把每个部分都安装为单独命名的包
# 我们更像把所有的部分联合在一起，用一个统一的前缀来命名

# 10.5.2 解决方案
# 基本上来说，这里的问题就是我们想定义一个顶层的Python包，把它作为命名空间来管理大量单独维护的子模块。这个问题常常会在大型的应用程序框架中出现，
# 框架开发人员希望鼓励用户发布自己的插件或者附加的包

# 要使各个单独的目录统一在一个公共的命名空间下，可以把代码向普通的Python包那样进行组织。但是对于打算合并在一起的组件，这些目录中的__init__.py
# 文件则需要忽略。为了说明这个过程，假设Python代码位于两个不同的目录中

# 在两个目录中，spam用来作为公共的命名空间。注意到这两个目录中都没有出现__init__.py
# 现在如果将foo-package和bar-package都添加到Python的模块的查询路径中，然后尝试一些导入操作

# import sys
#
# sys.path.extend(['foo-package','bar-package'])
# import spam.blah
# import spam.grok

#  将会注意到这两个不同的包目录魔法地合并在一起，我们可以随意导入spam.blah,spam.bar，不会有问题

# 10.5.3 讨论
# 这里的工作原理用到了一种称之为"命名空间包"(namespace package)的特性。基本上，命名空间包是一种特殊的包，设计这种特性的意图就是用来合并
# 不同目录下的嗲吗，并把它们放在统一的命名空间之下进行管理，就像示例那样。对于大型的框架而言，这种特性很有帮助。因为这样允许把框架的某些部分分解成
# 单独的安装包。这样也使得人们可以轻松地制作第三方插件和针对框架的其他扩展

# 创建命名空间包的关键是确保在统一命名空间的顶层目录中不包含__init__.py文件。当导入包的时候，这个缺失的__init__.py会出现一些问题。
# 解释器并不会因此而产生个错误，相反解释器开始创建里一个列表，把所有恰好包含有这个包名的目录都囊括在内。此时就创建出了一个特殊的命名空间包模块，
# 且在__path__变量中会保存一份只读形式的目录列表
#
# import spam
# print(spam.__path__)

# __path__变量中保存的目录可用来进一步定位包中的子模块(如，当导入spam.grok或spam.blah时)
# 命名空间包的一个重要特性就是任何人都可以用自己的代码来扩展命名空间中的内容。例如，假设在自己的目录下添加代码
# 如果把自己的代码目录和其他的包一起添加到sys.path中，那么就可以无缝地同其他的spam包合在一起

# 作为一种调试工具，想知道某个包是不是用来当做命名空间包的主要方式是检查它的__file__属性。如果缺少这个属性，这个包就是命名空间。
# 这也可以从包对象的字符串表示中看出，如果是命名空间的话，其中会有“namespace”的字样

