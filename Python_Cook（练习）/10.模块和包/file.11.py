# 10.11 利用import 钩子从远端机器上加载模块
# 10.11.1 问题
# 我们想对python的import 语句做定制化处理，实现以透明的方式从远端机器上加载模块
# 10.11.2 解决方案
# 本节的核心目标是扩展import 语句的功能。有几种方法可以实现这个目标，但是为了说明起见，我们先把python代码按照如下进行组织
# 这些文件无关紧要，但是可以在每个文件里添加简单的语句和函数，这样进行测试，当它们被导入时可以看到输出的结果。；


# 这么做的目的是允许这些文件能够以模块的形式从远端访问。也许最简单的方式就是在web服务器上发布这些模块。只需要进入testcode目录，运行python即可
# 让服务器一直运行，然后启动一个新的python解释器进程，确保可以通过urllib来访问这些远程文件
# 从服务器中加载源代码，这一思想是本章剩下内容的基础。与其通过urlopen()函数手动从服务器上把源代码抓取下来，如果自定义import 语句的行为
# 使其能够在幕后以透明的方式实现同样的目的
# 第一种用来加载远程模块的方法就是创建一个显式的加载函数。这个函数只是用来下载源代码的，利用compile()函数将其编译为code对象，然后在新创建
# 的模块对象的字典中执行他。
# 更加高级的方法是创建一个自定义的导入器(importer).实现这个目的的第一个方法是创建一个称之为元路径导入器(meta path importer)的组件
# 自定义导入功能的第二种方式是编写一个钩子(hook),直接将其插入到sys.path变量中，用来识别特定的目录命名模式。
# １０．１１．３　讨论
# 如果想创建一个新的模块对象(module object),可以使用imp.new_module()函数。模块对象通常会有集中属性，包括__file__(所加载模块的源文件名)
# 和__package__(包的名称，如果有的话)
# 其次，模块会被解释器做缓存处理。模块缓存可以在字典sys.modules中找到。由于存在缓存处理，通常我们就把缓存和模块的创建联合成一个单独的步骤来做
# 这么做的主要原因是如果某个给定名称的模块已经存在的话，就会直接得到已经创建好的模块了。
# 从最高层级来讲，import 操作要处理一系列"元路径"查询器，这些查询器可以在sys,meta_path中找到。如果