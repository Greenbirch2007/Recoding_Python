# 9.23  执行带有局部副作用的代码

# 9.23.1 问题
# 我们正在使用exec()在调用放的作用域下执行一段代码，但是当执行结束后，得到的结果似乎在当前作用域下是 不可见的

# 9.23.2 解决方案
# 我们在全局命名空间下只能修改以下代码





# python3 已经没有这个问题了 、需要使用locals()函数咋调用exec()之前获取一个保存在局部变量的字典。紧接着，就可以从本地字典中提取出修改过的值。

# 9.23.3 讨论
# 在大多数考虑使用exec()的情况下，可能存在着更加优雅的方案(例如装饰器，闭包，元类等)
# 默认情况下，exex()是在调用方的局部和全局作用域中执行代码的。然后在函数内部，传递给exec()的局部作用域是一个字典，而这个字典是实际局部变量的
# 一份拷贝。因此，如果在exec()中执行的代码对局部变量做出了任何修改，买这个修改绝对不会反映到实际的局部变量中区
# 当调用locals()来获取局部变量时，传递给exec()的是局部变量的拷贝。而在exec()执行完毕之后，通过检查字典中的值，就能获取到修改过的变量值
# 每当使用locals()时都需要小心操作的顺序问题。每次调用它时，locals()将会接受局部变量的当前值，然后覆盖字典中的对应条目


# 注意最后对locals()调用数如何导致x被覆盖的
# 处理使用locals()之外，另外一种可选的方式死创建字典并传递给exec().如下

def test():
    a = 13
    loc = {'a':a}
    glb = {}
    exec('b=a+1',glb,loc)
    b = loc['b']
    print(b)

test()

# 我们需要确保exec()中访问的变量在全局和局部字典中经过恰当的初始化
# 在使用exec()之前，应该问问自己是否还有其他的可选的方案。许多可能会考虑使用exec()的问题都可以用闭包，装饰器，元类或其他元编程的特性来替代