# 8.15 委托属性的访问
#　8.15.1　问题
#　我们想在访问实例的属性时能够将其委托(delegate)到一个内部持有的对象上，这可以作为继承的替代方案或为了实现一种代理机制

#　８．１５．２　解决方案
#　委托是一种编程模式。我们将某个特定的操作转交给(委托)另一种不同的对象实现。通常来说，最简单的委托形式如下

class A:
    def spam(self,x):
        pass
    def foo(self):
        pass

class B:
    def __init__(self):
        self._a = A()
    def spam(self,x):
        # delegate to the internal self._a instance
        return self._a.spam(x)

    def foo(self):
        # delegate to the internal self._a instance
        return self._a.foo()

    def bar(self):
        pass

#　如果仅有几个方法需要委托，编写向上面代码即可，但是如果有需要多方法委托另一种实现方式是定义__getattr__()方法

#　__getattr__()方法用来查找所有的属性。如果代码尝试访问一个并不存在的属性，就会调用这个方法。我们在访问B未定义的方法时
#　就能把这个操作委托给Ａ
#　委托的另一个例子就是在实现代理时，要使用这个代理类，只要简单地用它包装另一个实例即可
#　通过自定义实现属性的访问方法，就可以对代理进行定制化处理，让其表现出不同的行为(如，访问日志，只允许只读访问等)

#　8.15.3  讨论

#　委托有时候可以作为继承的替代方案
#　有时候当直接使用继承可能没有多大意义，或我们想更多地控制对象之间的关系(如，只想暴露出特定的方法，实现接口等)此时使用委托会很有用
#　当使用委托来实现代理时，注意几点：首先，__getattr__()实际上是一个回滚(fallback)，它只会在某个属性没有找到的时候才会调用。
#　因此，如果访问的是代理实例本身的属性(如本例子中的_obj属性)，这个方法就不会被触发调用。
#　其次,__setattr__(),__delattr__()方法需要添加一点额外的逻辑来区分代理实例本身的属性和内部对象_obj上的属性。常用的惯例是代理类
#　只委托那些不以下划线开头的属性(即，代理类只暴露内部对象中的"公有"属性)
#　同样需要重点强调的是__getattr__()方法通常不适用于大部分名称以双下划线开头和结尾的特殊方法。
#　如果尝试创建一个ListLike对象，就会发现它能支持常见的列表方法，例如,append()和insert().但是无法支持len(),查找元素等操作
#　要支持不同的操作，必须自行委托相应的特殊方法
#　11.8 的例子，在创建代理类时利用委托来完成远端过程调用

