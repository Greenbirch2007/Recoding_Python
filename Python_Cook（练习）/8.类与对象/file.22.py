# 8.22  实现非递归的访问者模式
# 8.22.1  问题

# 我们使用访问者模式来遍历一个深度嵌套的树结构，但由于超出Python的递归限制而崩溃。我想要去掉递归，但依旧
# 保持访问者模式的编程风格

# 8.22.2  解决方案
# 巧妙利用生成器可用来消除树的遍历或查找算法中的递归。前面已经给出了一个访问者类，下面这个类可以用另一种方式实现。通过堆栈和生成器来驱动计算
# 完全不使用递归

# 8.22.3 讨论

# 本节很好的展示了如何利用生成器和协程来控制程序的执行流。这个方法的优势：
# 1.首先，在有关遍历树结构的问题中，为了避免使用递归，常见的策略就是利用栈或队列来实现算法。
# 2. 其次，生成器中的yield语句的行为，当遇到yield语句时，生成器会产生出一个值然后暂停执行。
# yield本质上可当做一种信号来告诉算法当前处在yield状态的节点需要先被处理，之后剩下的处理才可以继续进行。

# 如何传递结果。当我们使用生成器函数时，我们不能再使用return语句来发送结果了(会产生SyntaxError异常)。yield语句必须承担这个责任
# 如果由yield语句产生出的值是非节点类型(non-Nodetype)的，则认为该值是要发送给计算过程中的下一个步骤的。

# 要消除对递归的使用，需要维护一个栈。也需要有某种方法管理对树结构的遍历以及调用各种访问这方法的逻辑。没有生成器，几乎是不可能的。使用
# yield的主要优势在于我们能够方法的写出非递归式的代码