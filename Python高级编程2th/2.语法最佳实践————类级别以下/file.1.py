# # # 2.1 python的内置类型
# #
# # # 2.1.1 字符串与字节
# #
# # # unicode字符串中包含无法用字节表示的“抽象文本”。因此如果unicode字符串没有被编码为二进制数据的话，是无法保存在磁盘中或通过网络发送的。
# # # 将字符串对象编码为字节序列有两个方法
# # # 1.利用str.encode(encoding,errors)方法，用注册编解码其(registered codec)对字符串进行编码
# # # 2. 利用bytes(source,encoding,errors)构造函数，创建一个新的字节序列
# #
# # # 用类似方法可以将bytes表示的二进制数据转换成字符串
# # # 1.利用bytes.decode(encoding,errors)方法，用注册编解码其对字节进行解码
# # # 2.利用str(source,encoding,error)构造和拿书，创建一个新的字符串实现与bytes()构造其类似
# # # 2.字符串拼接
# # # 1. +   2. str.join()  3.  字符串格式化可以用str.format()方法或%运算符
# # # 2.1.2 集合类型
# # #  列表，元组，字典，集合
# # #  元组是不可不变的，是可哈希的
# # # 对于需要真正的链表(双端append和pop操作的复杂都是O(1)的数据结构)的场景，Python内置的collections模块提供了deque(双端队列)
# # # 它是栈和队列的一般化，在需要用到双向链表的地方都可以实现这种数据结构
# # # （2）列表推导
# #
# # t =[i for i in range(10) if i %2 ==0]
# # # (3) 其他语法
# # # 另一个例子是使用enumerate(枚举)。在循环中使用序列时，这个内置函数可以很方便的获取其索引
# # # 如果需要一个一个合并多个列表(或任意可迭代对象)中的元素，那么可以使用内置的zip()函数，对两个大小相等的可迭代对象进行均匀遍历时，可以使用
# #
# # for item in zip([1,2,3],[4,5,6]):
# #     print(item)
# #
# # # 注意，对zip()函数返回的结果再次调用zip()，就可以将其恢复原状：
# #
# # for i in zip(*zip([1,2,3],[4,5,6])):
# #     print(i)
# # 另一个常用的语法元素就是序列解包(sequence unpacking).这种方法并不限于列表好元组，而是适用于任意序列类型(甚至包括字符串和字节序列)。
# # 只要赋值运算符左边的变量数目与序列中的元素数目相等，你看就可以用这个方法将元素序列解包到另一个变量中
#
# # 解包还可以利用带星号的表达式获取单个变量的多个水元素，只要它的解释没有歧义即可，还可以对嵌套序列进行解包。特别是在遍历有序列构成的复杂数据是
# # 带星号的用法很有用
#
#
# #　带星号的表达式可以获取序列的剩余部分
#
# f,s,*r = 0,2,3,5,4
# print(r)
#
# # 带星号的表达式可以获取序列的中间部分
#
# f,*i,l = 0,2,3,4,6,6
# print(i)
#
# # 嵌套解包
# (a,b),(c,d) = (1,2),(3,4)
# print(a,b,c,d)
#
# # 2.字典
# # dict可以将一组唯一键映射到对应的值。可以用全面列表推到类似的推到来创建一个新的字典
#
# sq= {number:number**2 for number in range(66)}
# print(sq)

# 重要的是，使用字典推导与列表推到有相同的优点，字典推到更加高效
# 在遍历字典元素时要注意，字典的keys(),values(),items()3个方法返回的类型不再是列表。而是返回的是视图对象(view objects)
d = {'a':1,"b":5}
print(d.keys())
print(d.values())
print(d.items())
# keys():返回dict_keys对象，可以查看字典的所有键
# values():返回dict_values对象，可以查看字典的所有值
# items()：返回dict_items随心，可以查看字典所有的(key,value)二元元组

# 视图对象可以动态查看字典的内容，因此每次字典发生变化时，视图都会发生变化
# for i in d.keys():
     # print(i)

# 视图对象既有旧的keys(),values(),items()方法返回的列表特性，也有旧的iterkeys(),itervalues(),iteritems()方法
# 返回迭代器的特定。视图无需将冗余地所有值都保存在内存里(如列表),但是你仍然可以获取其长度(使用len()),也可以测试
# 元素是否包含其中(使用in子句)。视图是可迭代的
# python3中，在keys(),values()方法返回的视图中，键和值的顺序是完全对应的。现在dict_keys,dict_values是动态的
# 所以即即使调用keys(),values()之间字典内容发生了变化，那么这两个视图的元素变量顺序是完全一致的

# （1）实现细节
# cpython使用伪随机探测(pseudo-random probing)的散列表(bash table)作为字典底层数据结构
# 只有可哈希的（hashable，即不可变）对象才能作为字典的键。如果一个对象有一个在整个生命周期都不变的散列值(hash value),而且
# 这个值可以与其他对象进行比较，那么这个对象就是可哈希的。python所有不可变的内置类型都是可哈希的。可变类型(如列表，集合)是不可哈希的
# 因此，列表和集合不可以作为字典的键。定义可哈希类型的协议包括下面两个方面：
# __hash__:这一方法给出dict内部实现需要的散列值(整数)。对于用户自定义类的实例对象，这个值由id()给出。
# __eq__:比较两个对象的值是否相等。对于用户自定义类，除了自身以外，所有实例对象默认不相等

# # 如果两个对象相等，那么它们散列值一定相等。反之则不一定成立。这说明可能发生散列冲突(hash collsion)，即散列值相等的两个对象可能并不相等。这是允许，
# 所以python实现都必须解决散列冲突，cpython用开发定址法(open addressing)来解决冲突。

#  字典的3个基本操作(添加元素，获取元素，删除元素)的平均时间复杂读为O(1),如果字典的键是用户自定义类的对象，并且散列方法不正确的话(发生冲突的风险很大)
# 那么这会给字典性能带来巨大的负面影响
# 在复制和遍历字典的操作中，最坏情况复杂度中的n是字典曾经达到的最大元素数目，而不是当前元素数目。因此在某些情况下，如果需要频繁遍历某个字典
# 那么最好创建一个新的字典对象，而不是仅在旧字典中删除元素
# （2）  缺点和替代方案
# 使用字典的常见陷阱之一，就是它并不会按照键的添加顺序来保存元素的顺序。在某些情况下，字典的键是连续的，对应的散列值也是连续值(如整数)
# 那么由于字典的内部实现，元素的顺序可能和添加顺序相同。如果使用散列方法不同的其他数据类型，那么字典就不会保存元素顺序
# 字典元素的顺序既与对象的散列方法无关，也与元素的添加顺序无关。在某些情况下，开发者可能需要使用能够保持添加顺序的字典。python标准库中的collections
# 模块提供了名为OrderedDict的有序字典。它选择性地接受一个可迭代对象作为初始化参数。

# from collections import OrderedDict
#
# t = OrderedDict((str(number),None) for number in range(5)).keys()
# print(t)


# OrderedDict还有一些其他功能，例如popitem()方法在双端取出元素或用move_to_end()方法指定元素移动到某一端。
# 3. 集合
#  集合是一种很好的数据结构，当元素顺序的重要性不如元素的唯一性和测试元素是否包含在集合中的的效率时，大部分情况下这种数据结构还是很有用的
# python的内置集合类型有两种
# 1.set():一种可变的，无序的，有限的集合，其元素是唯一的，不可变的(可哈希)对象
# 2.frozenset():一种不可变的，可哈希的，无序结合，其元素是唯一的，不可变的(可哈希的)对象

# 由于frozenset()具有不可变性，它可以作为用字典的键，也可以作为其他set(),frozenset()的元素。在一个set()或frozenset()中
# 不能包含另一个普通的set(),因为这会引发TypeError

# 创建可变集合方法有3种：
# 1.调用set(),选择性地接受可迭代对象作为初始化参数，如set([0,1,2])
# 2.使用集合推导，例如 {element for element in range(3)}
# 3. 使用集合字面值，如{1,2,3}
# 注意，使用集合的字面值和推导要注意，因为它们在形式上与字典的字面值和推导非常相似。此外，空的集合镀锡是没有字面值的，空的花括号{}表示的是空的字典字面值
