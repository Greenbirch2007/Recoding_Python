# # #  2.9 当列表不是首选时
# #
# #
# # #  如果要存放1000万个浮点数的化,数组(array)的效率会更高,背后是字节表述
# # #  如果要频繁对序列做先进先出的操作,deque(双端独立)速度更快
# #
# # #  如果检查元素是否 在序列中的包含操作,set(集合)更好
# #
# #
# # #  2.9.1 数组
# #
# # #  如果我们需要一个只包含数字的列表,那么array.array比list更高效.数组支持所有跟可变序列有关的操作,包括.pop,.insert,.extend.另外,数组
# # #  还提供从文件读取和存入文件的更快的方法,如.frombytes和.tofile
# #
# # #  Python数组跟c语言一样精简.创建数组需要一个类型码,这个类型码用来表示在底层的c语言应该存放怎么的数据类型.比如b类型码代表的是有符号的字符(signed char),
# # #  因此array('b)创建出的数组就只能存放一个字节大小的整数,范围从-128到127,这样在序列很大的时候,我们能节省很多空间.而且python不允许在数组里存放
# # #  除指定类型之外的数据
# # #  下面示例展示了从创建一个1000万个随机浮点数的数组开始,到如何把这个数组存放到文件里,再到如何从文件读取这个数组
# #
# # #  示例2-20   一个浮点型数组的创建,存入文件和从文件读取的过程
# #
# # from array import array
# # from random import random
# # floats = array('d',(random() for i in range(10**7)))
# # print(floats[-1])
# # fp = open('floats.bin','wb')
# # # 另外一个快速序列化数字类型的方法是使用pickle模块.pickle.dump处理浮点数组的速度几乎跟array.tofile一样快.不过前者可以处理几乎所有的内置数字类型,
# # #　包含复数，嵌套集合，甚至用户自定义的类．
# #
# #
# # #　还有一些特殊的数字数组，用来表示二进制数据，比如光栅图像．里面设计的bytes和bytearray乐行
# #
# #
# #
# # #　python3.4 开始，数据类型不在支持注入list.sort()这种就地排序方法，要给数组排序的话，得用sorted函数新建一个数组:
# # a = array.array(a.typecode,sorted(a))
# # #　要在不打乱次序的情况下为数组添加　新的元素:bisect.insort还是可以使用的
# #
# #
# # #　２．９．２　　内存视图
# #
# # #　内存视图(memoryview)是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片．memoryview的概念受到了numpy的启发
# #
# # #　内存视图其实是泛化和去数学化的numpy数组．它让你不在需要复制内容的前提下，在数据结构之间共享内存．其中数据结构可以是任何形式，比如PIL图片
# # #　SQLite数据库和NumPy的数组，等，这个功能在处理大型数据集合的时候很重要
# #
# #
# # #　memoryview.cast的概念跟数组模块类似，能用不同的方式读写同一块内存数据，而且内容字节不会随意移动．这听上去又跟C语言中类型转换的概念差不多．
# # #　memoryview.cast会把同一块内存里的内容打包成一个全新的memoryview对象给你
# #
# # #　示例２－２１　　通过改变数组中的一个字节更新数组里某个元素的值
# #
# #
# import array
#
# numbers = array.array('h',[-2,-1,0,1,2])
# memv = memoryview(numbers)
# print(len(memv))
# print(memv[0])
# memv_oct = memv.cast('B')
# print(memv_oct.tolist())
#
# # 另外，如果利用数组来做高级的数字处理是你的日常工作，那么numpy和scipy会经常使用
#
# #　２．９．３　　numpy和scipy
#
#
# #　使用numpy二维数组的基本操作
#
#
# #　示例２－２２　　对numpy.ndarray的行和列进行基本操作
#
import numpy
a = numpy.arange(12)
print(a)
print(type(a))
print(a.shape)
a.shape = 3,4
print(a)

# numpy也可以对numpy.ndarray中的元素进行抽象的读取，保存和其他操作

#　在介绍万扁平序列(包括标准数组和numpy数组)之后，界限了可以取代列表的另一个数据结构：队列

#　２．９．４　　双向队列和其他形式的独立

#　利用.append和.pop方法，我们可以把列表当做栈或队列来用（比如，把.append和.pop(0)集合起来用，救恩给你模拟栈的"先进先出"的特点）．但是删除
#　列表的第一个元素(或是第一个元素之前添加一个元素)之类的　操作很耗时，因为这些操作会牵扯到移动列表里的所有元素

#　collections.deque类（双向队列）是一个线程安全，可以快速从两端添加或删除元素的数据类型，而且如果想要有一种数据类型来存放"最近用到的几个元素"
#　deque也是一个很好的选择．这是因为在新建一个双向队列的时候，你可以指定这个队列的大小，如果这个队列满员了，还可以从反向端删除过期额元素，然后在尾端添加新的元素


#　使用2-23  使用双向队列

from collections import deque

dq = deque(range(10),maxlen=10)
print(dq)
dq.rotate(3)
print(dq)
dq.rotate(-4)
print(dq)
dq.appendleft(-99)
print(dq)
dq.append(8989)
print(dq)

dq.extendleft([10,20])
print(dq)

# maxlen是一个可选参数，代表这个队列可以容纳的元素的数量，而且一旦设定，这个属性就不能修改了
# 队列的选择操作接受一个参数n,当n>0时,队列的最右边的n个元素会把移动到队列的左边.当n<0时,最左边的n个元素会被移动到右边
#  当试图对一个已满(len(d) == d.maxlen)的队列做尾部添加操作的时候,它头部的元素会被删除掉.注意在下一行里,元素0被删除了
#  在尾部添加3个元素的操作会挤掉-1,1和2
#  extendleft(iter)方法会把迭代器里的元素逐个添加到双向队列的左边,因此迭代器里的元素会逆序出现在队列里

#  列表和双向嘟列这两个类型的方法(object类包含的方法除外)
#  双向队列实现了大部分队列所拥有的方法,也有一些额外的符合自身设计的方法,比如说,popleft和rotate.

#  但是双向队列为此付出了一些成本,从队列中间删除元素的操作会慢一些,因为它只对在头尾的操作进行了优化

#  append和popleft都是原子操作,也就是说deque可以在多线程程序中安全地当做先进先出的栈使用,而使用者不需要担心资源锁的问题

#  除了deque之外,还有其他的Python标准库也有对队列的实现

#  1.deque
#  提供了同步(线程安全)类queue,lifoqueue和priorityqueue,不同的线程可以利用这些数据类型来交换信息.这三个类的构造方法都有一个可选参数maxsize
#  它接收正整数作为输入值,用来限定队列的大小.但是在满员的时候,这些类不会扔掉旧的元素来腾出位置.相反,如果队列满了,它就会被锁住,直到另外的
#  线程移除了某个元素而腾出了位置.这一特性让这些类很适合用来控制活跃线程的数量


#  2. multiprocessing

#  这个包实现了自己的deque,它跟queue.Queue;类似,是设计给进程间通信用的.同时还有一个专门的multiprocessing.JoinableQueue类型,可以让
#  任务管理变得更加方便

#  3.  asyncio
#  专门为异步编程里的任务管理提供了专门的便利


#  4. heapq

#  跟上面三个模块不同的是,heapq没有队列类,而是提供了heaqpush和heappop方法,让用户可以把可变序列当做堆队列或优先队列来使用

#