# #  2.3 元组不仅仅是不可变的类别
#
# # 元组除了可以用作不可变的列表,它还可以用作没有字段名的记录
#
# # 2.3.1  元组和记录
#
# #　元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置．
#
# # 如果只把元组理解为不可变的列表，那其他信息－－它所包含有的元素的总数和它们的位置－－似乎变得可有可无．
# # 但是如果把元组当做一些字段的集合，那么数量和位置信息就变得很重要
#
# # 　示例２－７　　把元组用作记录
#
#
# lax_cor = (33.94,-113.843)
# city,year,pop,chg,area = ('Tokyo',2003,34250,0.66,8014)
# trad_id = [('USA','13446446'),('BRA','D354644'),('ESP','XAD131313')]
# for pa in sorted(trad_id):
#     print('%s/%s' % pa)
#
#
# print('~'*88)
# for country,_ in trad_id:
#     print(country)
# #  一个元组列表，元组的形式为(country_code,password_number)
# #　在迭代的的过程中，passport变量被绑定到每个元组上
# # ％　格式运算符能被匹配到对应的元组元素上
# # 　for循环可以分别提取元组里的元素，也叫作拆包(uppacking).因为元组中第二个元素对我们没有什么用，所以它赋值给"_" 占位符
#
# # 拆包让元组可以完美地当做记录来使用
#
#
# # ２．３．２　　元组拆包
#
# # 　一个%运算符就把passport元组里的元素对应到了print函数的格式字符串空挡中．这就是元组拆包
# # 元组拆包可以应用到任何可迭代对象上，唯一的硬性要求还是，被可迭代对象中的元素数量必须要跟接受这些元素的元组空挡数据一直．除非我们用*来
# # 最好辨认的元组拆包就是平行赋值，也就是说把一个可迭代对象里的元素，一并赋值到由对应的变量组成的元组中．
#
# l = (6,8)
# a,b = l
# print(a)
# print(b)
#
# # 另外一个写法属于不使用中间变量交换两个变量的值
#
# a,b = b,a
#
# # 还可以用* 运算符把一个可迭代对象拆开作为函数的参数
#
# print(divmod(20,8))
# t = (20,8)
# print(divmod(*t))
#
# # 元组拆包的用法则是让一个函数可以用元组的形式返回多个值，然后调用函数的代码就能轻松接受这些返回值．比如os.path.split()函数就会
# # 返回以路径和最后一个文件名组成的元组(path,last_part)
#
# import os
# _,filename = os.path.split('/home/sasfd/sadf/lslsls.txt')
# print(_)
# print(filename)
#
# # 在拆包的时候,我们不总是对元组里所有额数据都感兴趣,在元组拆包中使用*也可以帮助我们把注意力集中在元组的部分元素上
# # 用* 来处理剩下的元素
#
# # 在python中,函数用*args来获取不确定数量的参数,在Python3中扩展到了平行赋值
#
#
a,b,*res = range(6)
print(res) #一个列表
print(*res) # 剩下的元素
# 在平行赋值中,*前缀只能用在一个变量名前面,但是这个变量可以出现在赋值表达式的任意位置
#另外，元组拆包还可以应用到在嵌套结构中

# 2.3.3    嵌套元组拆包

# 接受表达式的元组可以是嵌套的,例如(a,b,(c,d))只要这个接受元组的嵌套结构符合表达式本身的嵌套结构,Python就会做出正确对象呀


#　2-8 用嵌套元组来获取经度

# 每个元组内有４个元素，其中最后一个元素是一对坐标
# 我们把输入元组的最后一个元素拆包到由变量构成的元组里,这样就获取了坐标

# 元组作为记录来用,少了一个功能:我们时常会需要给记录中的字段命名.namedtuple具名元组解决了这个问题

# 2.3.4  具名元组

# collections.namedtuple是一个工厂函数,它可以用来构建一个带字段名的元组和一个有名字的类--这个带名字的类对调试程序有很大帮助

# 用namedtuple 构建的类的实例所消耗的内存跟元组是一样的,因为字段名都被存在对应的类里面.这个实例跟普通的对象实例比起来要小一些,因为
# python不会用__dict__来存放这些实例的属性

# 示例2-9  定义和使用具名元组

from collections import namedtuple

City = namedtuple('City','name country population cor')
tokyo = City('Tokyo','JP','36.9',(35.62,139.69))
print(tokyo)
print(tokyo.cor)
print(tokyo.name)

# 1.创建一个具名元组需要两个参数,一个是类名,另一个是类的各个字段的名字.后者可以是由数个字符串组成的可迭代对象,或是由空格分隔开的字段名组成的字符串
#  2. 存放在对应字段里的数据要以一串参数的形式传入到构造函数中(注意,元组的构造函数却只接受单一的可迭代对象)
# 3. 可以通过字段名或位置来获取一个字段的信息

# 除了从普通元组那里继承来的属性之外,具名元组还有一些自己专有的属性.常用的属性如下

#  _fields类属性,  类方法_make(iterable)和实例方法_asdict()


# 示例2-10  具名元组的属性和方法
print(88*'~')
print(City._fields)
lat = namedtuple('lat','la long')
del_data = ('ssarwe','ss',21.46,(424,434))
deli_ = City._make(del_data)
print(deli_._asdict())
for key,value in deli_._asdict().items():
    print(key + ':',value)

# 1. _fields属性是一个包含这个类所有字段名称的元组
# 2. 用_make()通过接受一个可迭代对象来生成这个类的一个实例,它的作用跟City(*deli_data)是一样的
# 3. _asdict()把具名元组以collections.OrderedDict的形式返回,我们可以利用它把元组的信息友好地呈现出来
# 元组是一个很强大的可以当做记录来用的数据类型.它的第二个角色则是充当一个不可变额列表

#　2.3.5　　作为不可变列表的元组


#　如果要把元组当做列表咏鹅化．除了跟增减元素相关的方法之外，元组支持列表的其他所有方法．还有一个例外，元组没有__reversed__方法，但是这个方法
#　只是优化而已，reversed(my_tuple)这个用法在没有__reversed__的情况也是合法的

# 列表或元组的方法和属性(那些由object类支持的方法没有列出来)

#　形式                                          表述           列表    元组

# 1.　s.__add__(s2)  s+s2,拼接                       有     有
#　2. s.__iadd__(s2)  s+=s2, 就地拼接               有      无
#　3. s.append(e)  在尾部添加一个新元素             有      无
#　4. s.clear()   删除所有元素                      有     无
#　5.s.__contain__(e)  s是否包含e                有       有
#　6. s.copy()    列表的浅赋值                    有       无
#　7. s.count(e)  e在s中出现的次数                   有      有
#　8.s.__delitem__(p)  把位于p的元素删除            有       无
#　9. s.extend(it)  把迭代对象it追加给s           有       无
#　10. s.__getitem__(p)  s[p],获取位置p的元素      有       有
#　11. s.__getnewargs__()  在pickle中支持更加优化的序列化   无        有
#　12. s.index(e)  在s中找到元素e第一次出现的位置       有        有
#　13. s.insert(p,e)  在位置p之前插入元素e            有       无
#　14.s.__iter__()   获取s的迭代器              有       有
#　15. s.__len__()     获取len(s),元素的数量       有         有
#　16.s.__mul__(n)  s* n,n个s的重复拼接          有       有
#　17. s.__imul__(n) s *= n ,就地重复拼接       有        无
#　18.s.__rmul__(n) n*s,反向拼接          有      有
#　19.s.pop([p])   删除最后或是(可选的)位于p的元素,并返回它的值       有     无
#　20. s.remove(e)  删除s中的第一次出现的e       有    无
#　21.  s.reverse()     就地把s的元素倒序排列    有      无
#　22.  s.__reversed__()   返回s的倒序迭代器        有      无
#　23. s.__setitem__(p,e)   s[p] =e,把元素e放在位置p,替代已经在那个位置的元素
#　24. s.sort([key],[reverse])  否倒序(reverse)  有   无