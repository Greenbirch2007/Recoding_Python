# #  2.2  列表推导和生成器表达式
#
# #  列表推导是构建列表(list)的快捷方式,而生成器表达式则可以用来创建其他任何类型的序列
#
#
# #  2.2.1   列表推导和可读性
#
#
# #  示例2-1   把一个字符串编程Unicode码位的列表
#
# s = '$@#$%#%^'
# codes = []
# for sy in s:
#     codes.append(ord(sy))
#
# print(codes)
#
# # 示例2-2  把字符串编程Unicode码位的列表推导写法
#
# codes1 = [ord(sy) for sy in s]
# print(codes1)
#
#
# # for 循环可以胜任很多:遍历一个序列以求得总数或挑出某个特定的元素,原来计算总和或平均数,还有其他任何香菇走的是
#
# # 另一方面,列表推导的滥用,用列表推导来重复获取一个函数的副作用.通常的原则是,只用列表推导来创建新的列表,并且尽量保持简短.如果列表推导的代码
# #　超过了两行，就要考虑使用for循环重新了，
#
# # python会忽略代码里[],{},()中的换行,因此如果你的代码里有很多行的列表,列表推导,生成器表达式,字典这一类的.可以省略不太好看的续行符\
#
#
# #  列表推导不会再有变量泄漏的问题
#
# #  列表替代,生成器表达式,以及同它们很相似的集合(set)推导和字典(dict)推导,在python3中都有了自己的局部作用域,就像函数似的.表达式内部的
# # 变量和复制只在局部起作用,表达式的上下文里的同名变量还可以被正常引用,局部变量并不会影响它们
#
# # 列表推导可以帮助我们把一个序列或是其他可迭代类型中的元素过滤或是加工,然后再新建一个列表.Python内置的filter或map函数组合起来也能实现
# #　2.2.2　列表推导同fiter和map的比较
#
# # ２．２．３　　笛卡尔积
#
# # 用列表推导可以生成两个或以上的可迭代类型的笛卡尔积，笛卡尔积是一个列表，列表里的元素是由输入的可迭代类型的元素对构成的元组，因此，笛卡尔积列表
# # 长度等于输入变量的长度的乘积
#
# # 示例２－４　使用列表推导计算笛卡尔积
#
#
# colors = ['black','white']
# sizes = ['S','M','L']
# tshirts = [(color,size) for color in colors for size in sizes]
# print(tshirts)
# for color in colors:
#     for size in sizes:
#         print((color,size))
#
# # 列表推导的作用只有一个：生成列表．如果想生成其他类型的序列，生成器表达式就可以使用．
# # ２．２．４　　生成器表达式
#
# # 虽然也可以用列表推导来初始化元组，数组或其他序列类型，但是生成器表达式是更好的选择．这是因为生成器表达式别后遵循了迭代器协议，可以
# # 逐个地产出元素，而不是先建立一个完整的列表，然后再把逐个列表传递到某个构造函数里，前面那种方式显然能够节省内存
#
# # 生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已
#
# # 示例2-5  用生成器表达式初始化元组和数组
#

symbols = '#$%$%^@$%^#'
print(tuple(ord(sy) for sy in symbols))
import array
print(array.array('I',(ord(sy) for sy in symbols)))

# 如果生成器表达式是一个函数调用过程中的唯一参数,那么不需要额外再用括号把它为其啦


# array数组的构造方法需要两个参数,因此括号是必需的.array构造方法的第一个参数制定了数组中数字的存储方式

# 用到生成器表达式之后,内存里不会留下一个有6个组合的列表,因为生成器表达式会在每次for循环运行时才生成一个组合.如果要计算两个各有1000个元素
# 的列表笛卡尔积,生成器表达式就可以帮忙省掉运行for循环的开销,即一个含有100万个元素的列表


# 示例2-6  使用生成器表达式计算笛卡尔积

colors = ['black','white']
sizes = ['S','M','L']
for tshirt in ('%s %s' %(c,s) for c in colors for s in sizes):
    print(tshirt)


