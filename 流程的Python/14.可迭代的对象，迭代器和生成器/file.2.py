# 14.2  可迭代的对象和迭代器的对比


# 可迭代的对象
# 使用iter内置函数可以获取迭代器的对象.如果对象实现了能返回迭代器的__iter__方法,那么对象就是可迭代的.序列都可以迭代;实现了__getitem__方法,而且
# 其参数是从零开始的索引,这种对象也可以迭代

# python从可迭代的对象中获取迭代器

# s = 'ABC'
# for i in s:
#     print(i)

# 如果没有for语句,不得不使用while循环模拟,如下

s = 'ABC'
it = iter(s)
while True:

    try:
        print(next(it))
    except StopIteration:
        # del it
        break
# 使用可迭代的对象构建迭代器it.不断在迭代器上调用next函数,获取下一个字符

# StopIteration异常表明迭代器到头了.Python语言内部会处理for循环和其他迭代上下文(如,列表推导,元祖拆包等 )中的StopIteration异常

# 标准的迭代器接口有两个方法

#  1. __next__  返回一个可用的元素,如果没有元素了,抛出StopIteration异常
# 2. __iter__   返回self,以便在应该使用可迭代对象的地方使用迭代器,如for循环中

# 这个接口在collections.abc.Iterable 抽象基类中制定.这个类定义了__next__抽象方法 ,而且继承自Iterable类;__iter__抽象方法则在Iterable类中定义


# Iterable和Iterator抽象基类,以斜体显式的是抽象方法,具体的Iterable.__iter__方法应该返回一个Iterable实例
# 具体的Iterator类必须实现__next__方法.Iterator.__iter__方法直接返回实例本身


# Iterator抽象基类实现__iter__方法的方式是返回实例本身(return self) .这样需要可迭代对象的地方可以使用迭代器


# 迭代器
# 迭代器这样的对象:实现了无参数的__next__方法,返回序列中的下一个元素;如果没有元素了,那么抛出StopIteration异常.python中的迭代器还实现了__iter__方法,因此迭代器也是可以迭代的

#　迭代器模式可用来
# １．　访问一个聚合对象的内容而无需暴露它的内部表示
# ２．　支持对聚合对象的多种遍历
# ３．　为遍历不同的聚合结构提供一个统一的接口(即支持多态迭代)

# 为了＂支持多种遍历＂，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且各个迭代器要能维护自身的内部状态，因为这一模式正确的实现方式是，每次调用iter(my_iterable)
# 都新建一个独立的迭代器．这就是为什么这个示例需要定义SentenceIterator类

# 注意，　可迭代的对象一定不能是自身的迭代器．可迭代的对象必须实现__iter__方法，但不能实现__next__方法
# 另一方面，迭代器应该一直可以迭代，迭代器的_iter__方法应该返回自身


# １４．４　　生成器函数

# Senence类中，__iter__方法调用SenenceIterator类的构造方法创建一个迭代器并将其返回．迭代器其实是生成器的对象，每次调用__iter＿方法都会自动创建，因为这的__iter__方法是生成器函数
# 生成器函数的工作原理
# 只要python函数的定义体中有yield关键字,该函数就是生成器和拿书.调用生成器函数时,会返回一个生成器对象.生成器函数是生成器工厂
# 一个迭代器,可以使用Next()会获取yield生成的下一个元素

# 生成器函数会创建一个生成器对象,包装生成器函数的定义体.把生成器传给next()函数时,生成器函数会向前,执行函数定义体中的下一个yield语句,返回产出的值,并在函数定义体的
# 值,并在函数定义体的前位置暂停.最后在那个,函数的定义体返回时,外层的生成器对象会抛出 StopIteration,这一点与迭代器协议一致


# 生成器不会以常规的方式"返回"值:生成器函数体中的return语句会触发对象抛出StopIteration异常.只有把生成器函数当成协程使用,才有意义
# __iter__方法是生成器函数,调用时会构建一个实现了迭代器接口的生成器对象