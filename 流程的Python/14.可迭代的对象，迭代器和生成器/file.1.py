#  第14章 可迭代的对象,迭代器和生成器
# 迭代是数据处理的基础.扫描内存中放不下的数据时,我们要找到一种团队型获取数据项的方式,即按需一次获取一个数据项.这就是迭代器模式(Iterator pattern)
# 所有生成器都是迭代器,因为生成器完全实现了迭代器接口.在python中,生成器有广泛的用途.现在,即使是内置range()函数也返回一个类似
# 生成器的对象,而以前则返回完整的列表.如果一定要让range()函数返回列表,那么必须明确指明(如,list(range(100)))

# 在Python中,所有集合都是可以迭代的.在python语言内部,迭代器用于支持:(6个)

# 1. for循环
# 2. 构建和扩展集合类型
# 3.逐行遍历文本文件
# 4. 列表推导,字典推导和集合推导  (3个类型的推导)
# 5. 元组拆包
# 6. 调用函数时,使用*拆包实参

# 本章涉及以下主题:
# 1. 语言内部使用iter()内置函数处理可迭代对象的方式
# 2. 如何使用python实现经典的迭代器模式
# 3. 详细说明生成器函数的工作原理
# 4. 如何使用生成器函数或生成器表达式代替经典的迭代器
# 5. 如何使用标准库中通用的生成器函数
# 6. 如何使用yield from语句合并生成器
# 7. 案例分析:在一个数据库转换工具中使用生成器函数处理大型数据集
# 8. 为什么生成器和协程看似相同,实际差别很大

# 首先,来研究iter()函数如何把序列变得可以迭代
# 序列可以迭代的原因:iter函数
# 解释器需要迭代对象x时,会自动调动iter(x)

#  内置的iter函数有以下作用:
# (1) 检查对象是否实现了__iter__方法,如果实现了就调用它,获取一个迭代器
# (2) 如果灭有实现__iter__方法,但是实现了__getitem__方法,Python会创建一个迭代器,尝试按顺序(从索引0开始)获取元素
# (3) 如果尝试失败,Python抛出TypeError异常,通常会提示"C object is not iterable"(C 对象不可迭代).其中C是目标对象所属的类
#  任何Python序列都可迭代的原因是,它们都实现了__getitem__方法.其实,标准的序列也都实现了__iter__方法,因此你也应该这么做.
# 之所以对__getitem__方法做特殊处理,是为了向后兼容,而未来可能不会再如此了
# 这是鸭子类型(duck typing)的极端形式:不仅要实现特殊的__iter__方法,还要实现__getitem__方法,而且__getitem__方法的参数是从0开始的整数(int),这样才认为对象是可迭代的
# 在白鹅类型(goose-typing)理论中,可迭代对象的定义简单一些:如果实现了__iter__方法,那么就认为对象是可迭代的.此时不需要创建子类,也不用注册
# 因为abc.Iterable类实现了__subclasshook__FANGFA


class Foo:
    def __iter__(self):
        pass

f = Foo()
from collections import abc

print(issubclass(Foo,abc.Iterable))
f = Foo()

print(isinstance(f,abc.Iterable))

# 从python3.4开始,检查对象x能否迭代,最准确的方法是:调用iter(x)函数,如果不迭代,再处理TypeError异常.这比使用isinstance(x,abc.Iterable)更准确
#　　因为iter(x)函数会考虑到遗留的__getitem__方法，而abc.Iterable类则不考虑

# 迭代对象之前显式检查对象是否可迭代或许没有必要,毕竟尝试迭代不可迭代额对象时,python抛出的异常信息很明确
# 如果除了抛出TypeError异常之外还要进一步的吹了,可以使用try/except块,而无需显式检查.如果要保存对象,等以后再迭代,或许可以显式检查,因为这种情况
# 可能需要尽早捕捉错误
