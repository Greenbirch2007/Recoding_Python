# 14.5  惰性实现

# 设计Iterator接口时考虑到了惰性:next(my_iterator)一次生成一个元素


#　１４．６　　生成器表达式
# 简单的生成器函数，可以替换成生成器表达式
# 生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性地生成元素．如果列表推导是制造列表的工厂，那么
# 生成器表达式就是制造生成器的工厂


# 示例１４．８　　　先在列表推导中使用gen_AB 生成器函数，然后在生成器表达式中使用



def gen_AB():
    print('start:~~~~~')
    yield 'A'
    print('continue~~~~~')
    yield 'B'
    print('end!')

# res1 = [x*3 for x in gen_AB()]
#
#
# print('88'*'@')
#
# for i in res1:
#     print('----->',i)

# 生成器表达式会产出生成器，因此可以使用生成器表达式减少代码量

# 生成器表达式是语法糖:完全可以替换成生成器函数,不过有时使用生成器表达式更简便

# 14.7  何时使用生辰器表达式
# 前面为了实现Vecotr类,用了几个生成器表达式,__eq__,__hash__,__abs__.angle,angles,format,中各自有一个生成器表达式.在这些方法中使用列表推导赢,
# 不过立即返回的列表要使用更多的内存

# 生成器表达式是创建生成器的简洁句法,这样无需先定义函数再调用.不过,生成器函数灵活得多,可以使用多个语句实现复杂的逻辑,也可以作为协程使用
# 遇到简单的情况时,可以使用生成器表达式
# 如果生成器表达式要分成多行写,推荐定义大亨和储能器函数,以便提高可读性,生成器函数有名称,可以重用

# 如果函数或构造方法只有一个参数,传入生成器表达式时不用写一对调用函数的括号,再写一对括号围住生成器表达式,致谢一对括号即可

# 14.8 等差梳理生成器