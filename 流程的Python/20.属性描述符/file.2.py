# # 2.2 覆盖型与非覆盖型描述符对比
#
#
# #   python 存取属性的方式特别不对等，通过实例读取属性时，通常返回的是实例中定义的属性；但是，如果实例中没有指定的属性，那么会获取类属性．
# #  而为实例中的属性赋值时,通常会在实例中创建属性,根本不影响
#
# #  这种不对等的处理方式对的描述符也有影响,其实,根据是否定义__set__方法,描述符可以分为两类.
#
# #  下面示例中,每个__get__和__set__方法都调用了print_args函数,是调用方式易于阅读.没有必要深入理解print_args函数及辅助函数cls_name和
# #  display,因此不要花心思押金它们
#
#
# #　示例２０－８　　　几个简单的类：用于研究描述符的覆盖行为
#
# #  20.2.1  覆盖型描述符
#
# #  实现__set__方法的描述符属于覆盖型描述符，因为虽然描述符是类属性，但是实现　__set__方法的话，会覆盖对实例属性的赋值操作．
# #  示例２０－２　　就是这样实现的，
# #  特性也是覆盖型描述符：如果没有提供设置函数，property类中的__set__方法会抛出AttributeError异常，指明哪个属性是只读的．
# #  我们可以使用上面的代码测试覆盖型描述符的行为
#
# #  示例２０－９　　覆盖型描述符的行为：其中obj.over是Overriding类的示例
#
# from detokinds import Managed
#
# obj = Managed()  # 1.创建供测试使用的Managed对象
# obj.over  # 2.obj.over触发描述符的__get__方法，第二个参数的值是托管实例obj
# print(88*'~')
# Managed.over  # 3. Managed.over触发描述符的__get__方法，第二个参数(instance)的值是None
# print(88*'~')
# obj.over = 7  # 4. 为obj.over赋值，触发描述符的__set__方法，最后一个参数的值是７
# print(88*'~')
# obj.over # ５．　读取obj.over,仍会触发描述符的__get__方法
# obj.__dict__['over']= 8 # 6.跳过描述符，直接通过obj.__dict__属性设置
# print(88*'~')
# print(vars(obj))  # 7. 确认值在obj.__dict__属性中，在over键名下
# print(88*'~')
# obj.over # 8. 然而，即使是名为over的实例属性，Managed.over描述符仍会覆盖读取obj.over这个操作
#
#
# #  20.2.2  没有__get__方法的覆盖型描述符
#
# #　通常，覆盖型描述符既会实现__set__方法，也会实现__get__方法，不过也可以只实现__set__方法
# #　此时只有写操作由描述符处理．通过实例读取描述符会返回描述符对象本身，因为没有处理读操作的__get__方法．
# #　如果直接通过实例的__dict__属性创建同名实例属性，以后再设置那个属性时，仍会由__set__方法插手接管，
# #　但是读取那个属性的话，就会直接从实例中返回新赋予的值，而不会返回描述符对象．
# #　实例属性会覆盖描述符，不过只有读操作是如此
#
# #　示例２０－１０　　没有__get__方法的覆盖型描述符，其中obj.over_no_get是OverridingNoGet类的实例
#
# 1. 这个覆盖型描述符没有__get__方法，因此，obj.over_no_get从类中获取描述符实例
#　２．　直接从托管类中读取描述符实例如此
#　３．　为obj.over_no_get赋值会触发描述符的__set__方法
#　４．　因为__set__方法没有修改属性，所以在此读取obj.over_no_get获取额仍是托管类中的描述符实例
#　５．　通过实例的__dict__属性设置名为over_no_get的实例属性

#　２０．２．３　　非覆盖型描述符

#　没有实现__set__方法的描述符是非覆盖型描述符．如果设置了同名的实例属性，描述符会被遮盖，致使描述符无法处理那个实例的那个属性．
#　方法是以非覆盖型描述符实现的

#　２０．２．４　　在类中覆盖描述符
