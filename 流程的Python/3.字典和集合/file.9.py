#  ３．９　　dict和set的背后


#  有几个问题？

#  １．　python里的dict和set的效率有多高？
#  ２．　为什么它们是无序的？
#  ３．　　为什么并不是所有的python对象都可以当做dict的键或set里的元素？
#  ４．　　为什么dict的键和set元素的顺序是根据它们被添加的次序而定的，以及为什么在映射对象的声明周期中，这个顺序并不是一成不变的？
#  ５．　为什么不应该在迭代循环dict或set的同事添加元素？

#  ３．９．１　一个关于效率的实验
#  ３．９．２　　字典中的散列表

#  散列表其实是一个稀疏数组(总是有空白元素的数组成为稀疏数组)．在一般的数据结构中，散列表里的单元通常叫做表元(bucket).在dict的散列表当中
#  每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个对值的引用．因为所有表元的大小一致，所以可以通过偏移量来读取某个表元


#  ３．９．３　　dict的实现及其导致的结果

#  １．键必须是可散列的

#  一个散列的对象必须满足以下要求
#  （１）　支持hash()函数，并通过__hash__()所得到的散列值是不可变的
#  （2） 支持通过__eq__()方法来检测相等性
#  （３）　若a==b为真，则hash(a) == hash(b)也为真

#  ２．　字典在内存上的开销巨大
#  ３．　键查询很快

#  ４．　键的次序取决于添加顺序
#  ５．　往字典里添加新键可能会改变已有键的顺序

#  无论何时往字典里添加新的键，python解释器都可能做出为字典扩容的决定．扩容导致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里
# ３．９．４　set的实现以及导致的结果


#  set和frozenset的实现也依赖散列表，但在它们的散列表里存放的只有元素的引用(就像在字典里只存放键而没有相应的值)，在set加入到python之前，我们
#  都是把字典加上无意义的值当做集合来用的

#  集合具有的特点

#  １．集合里的元素必须是可散列的
#  ２．集合很消耗内存
#  ３．可以很高效地判断元素是否存在于某个集合
#  ４．元素的次序取决于被添加到集合里的次序
#  ５．往集合里添加元素，可能会改变集合里已有元素的次序


#