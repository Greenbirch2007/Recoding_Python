# 17.2  阻塞型I/O和GIL


# cpython解释器本身就不是线程安全的,因此有全局解释器锁(GIL),一次只允许使用一个线程执行python字节码.因此,一个Python进程通常不能同时
# 使用多个CPU核心

# 编写python代码时无法控制GIL,不过,执行耗时的任务时,可以使用一个内置的函数或一个使用C语言编写的扩展释放GIL.其实,有个使用C语言编写的python
# 库能管理GIL,自行启动操作系统线程,利用全部可用的CPU核心这样做会极大地增加库代码的复杂度,


# 一个Python线程等待网络响应时,阻塞型i/o函数释放GIL,再运行一个线程

# python标准库中的所有阻塞型i/o函数都会释放GIL,允许其他线程运行.time.sleep()函数也会释放GIL.因此,尽管有GIL,python线程还是能在i/o密集型应用中发水作用

# 17.3  使用concurrent.futures模块启动进程

# 17.4  实现Executor.map 方法
# 17.5  显示下载进度并处理错误