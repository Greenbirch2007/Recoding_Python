# 7.4  变量作用域规则
# 我们定义并测试了一个函数，它读取两个变量的值：一个是局部变量a,是函数的参数；另一个是变量b，这个函数没有定义它



# 示例7.4  一个函数，读取一个局部变量和一个全局变量


# def f1(a):
#     print(a)
#     print(b)

# 如果，先给全局变量b赋值，然后再为b赋值，然后再调用f，那就不会出错

#　示例７．５　b是局部变量，因为在函数的定义体中给它赋值了
# b = 6
#
# def f2(a):
#     print(a)
#     print(b)
#     b = 9


# print(3)
# 事实上，python编译函数的定义体时，它判断b是局部变量，因为在函数中给他赋值了。生成的字节码证实了这种判断，python会尝试从本地环境获取b.
# 后面调用f2(3)时，f2的定义体会获取并打印局部变量a的值，但是尝试获取局部变量b的值时，发现b没有绑定值


# 这不是缺陷。而是设计选择：python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。这比javascript好多了，javascript也不要求
# 声明变量，但是如果忘记把变量声明为局部变量(使用var ),可能会在不知情的情况下获取全局变量

# 如果在函数中赋值时想让解释器把b当成全局变量，要使用global声明


b = 6
def f3(a):
    global b
    print(a)
    print(b)
    b = 9
f3(3)
f3(3)
f3(3)

#　了解python的变量作用域之后，可以看闭包
# 比较字节码
# dis模块为反汇编python函数字节码提供了简单的方式